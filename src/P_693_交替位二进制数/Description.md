交替二叉树  我的第一想法是 对比

例如5  101 直接 右移两次  与  判断末尾0或1 + 右移两次 再左移两次的值。


额。题目是 相邻的两个位数永不相等。

好吧  那就一直右移 且判断最右侧的值。？好像不对
1011 与101对比？还不如获取最右侧的1
如果第一次获取的值的平方 == 第二次获取值
如果1的位置超过3位 即 100 即为false

如果为true 则继续执行删除了一个1的结果。


去掉最后一位          ¦ (101101->10110)          ¦ x >> 1
在最后加一个0        ¦ (101101->1011010)        ¦ x < < 1
在最后加一个1        ¦ (101101->1011011)        ¦ x < < 1+1
把最后一位变成1      ¦ (101100->101101)          ¦ x ¦ 1
把最后一位变成0      ¦ (101101->101100)          ¦ x ¦ 1-1
最后一位取反          ¦ (101101->101100)          ¦ x ^ 1


似乎有了新的解决方案


判断最右为是0 还是1。
    如果是0   例如1010 右移一位变成101  ----与----  左移一位 10100  +1 变成 10101 左移两位 对比
    如果是1   例如10101 右移一位变城1010    ----与----  左移 一位 101010 变成10101


左移两位 与 最左侧添加一个10对比。


两种操作 一个是在最左侧操作 一个是在最右侧操作   对比操作结果

x 右移一位 。得到tmp

①tmp 左移1位 补全末尾

②tmp 最左侧  怎么补全   例如10101  tmp = 1010  最右侧0 补全1 左移10100 +1
                          101010 tmp = 10101 最右侧1 补全0 左移101010


然此再依次右移一位判断